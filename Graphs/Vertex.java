package GeoNet.Graphs;import java.util.Iterator;import java.util.LinkedList;import java.util.List;import java.util.NoSuchElementException;/** * A class that represents a vertex in a graph. */class Vertex<E> implements VertexInterface<E>{    private E label;    private List<Edge> edgeList; // edges to neighbors    private boolean visited;                          // true if visited    private VertexInterface<E> previousVertex;        // previous vertex on path to this vertex    private double cost;                              // cost of path to this vertex    /**     *     * @param vertexLabel object representing the vertex     */    public Vertex(E vertexLabel)    {        this.label = vertexLabel;        this.edgeList = new LinkedList<>();        this.visited = false;        this.previousVertex = null;        this.cost = 0;    }    /**     *     * @return the object label of the vertex     */    public E getLabel()    {        return this.label;    }    /**     *     * @param endVertex  a vertex in the graph that ends the edge     * @param edgeWeight a real-valued edge weight, if any     * @return true if the vertices are distinct and the edge is not a duplicate     */    public boolean connect(VertexInterface<E> endVertex, double edgeWeight)    {        boolean result = false;        if (!this.equals(endVertex)) {            Iterator<VertexInterface<E>> neighbors = this.getNeighborIterator();            boolean duplicateEdge = false;            while (!duplicateEdge && neighbors.hasNext()) {                VertexInterface<E> nextNeighbor = neighbors.next();                if (endVertex.equals(nextNeighbor)) duplicateEdge = true;            }            if (!duplicateEdge) {                this.edgeList.add(new Edge(endVertex, edgeWeight));                result = true;            }        }        return result;    }    /**     *     * @param endVertex a vertex in the graph that ends the edge     * @return true if the vertices are distinct and the edge is not a duplicate     */    public boolean connect(VertexInterface<E> endVertex)    {        return connect(endVertex, 0);    }    /**     *     * @return an iterator consisting of the neighboring vertices     */    public Iterator<VertexInterface<E>> getNeighborIterator()    {        return new NeighborIterator();    }    /**     *     * @return an iterator consisting of the neighboring edge weights     */    public Iterator<Double> getWeightIterator()    {        return new WeightIterator();    }    /**     *     * @return true if the degree of this vertex is greater than 0 (i.e. it has at least one edge)     */    public boolean hasNeighbor()    {        return !this.edgeList.isEmpty();    }    /**     *     * @return the first neighboring vertex that has not yet been visited.     * If all neighbors have been visited, returns null     */    public VertexInterface<E> getUnvisitedNeighbor()    {        VertexInterface<E> result = null;        Iterator<VertexInterface<E>> neighbors = getNeighborIterator();        while (neighbors.hasNext() && (result == null)) {            VertexInterface<E> nextNeighbor = neighbors.next();            if (!nextNeighbor.isVisited()) result = nextNeighbor;        }        return result;    }    /**     *     * @return true if this vertex has a parent     */    public boolean hasPredecessor()    {        return this.previousVertex != null;    }    /**     *     * @return the parent vertex. If there is no parent, returns null     */    public VertexInterface<E> getPredecessor()    {        return this.previousVertex;    }    /**     *     * @param predecessor the vertex previous to this one along a path     */    public void setPredecessor(VertexInterface<E> predecessor)    {        this.previousVertex = predecessor;    }    /**     * mark this vertex as visited     */    public void visit()    {        this.visited = true;    }    /**     * mark this vertex as not visited     */    public void unvisit()    {        this.visited = false;    }    /**     *     * @return true if this vertex has been visited     */    public boolean isVisited()    {        return this.visited;    }    /**     *     * @return the weight of the path that lead to this vertex     */    public double getCost()    {        return this.cost;    }    /**     *     * @param newCost the cost of the path     */    public void setCost(double newCost)    {        this.cost = newCost;    }    /**     *     * @param other compare to other object     * @return true if objects are both vertices whose labels are equivalent     */    public boolean equals(Object other)    {        boolean result;        if ((other == null) || (getClass() != other.getClass())) result = false;        else {            // the cast is safe because other has the same type as this object            @SuppressWarnings("unchecked") Vertex<E> otherVertex = (Vertex<E>) other;            result = this.label.equals(otherVertex.label);        }        return result;    }    /**     *     * @return string representation of the vertex's label     */    public String toString()    {        return this.label.toString();    }    /**     * used for testing     */    public void display()    {        System.out.print(this.label + " -> ");        Iterator<VertexInterface<E>> vertexIterator = getNeighborIterator();        Iterator<Double> weightIterator = getWeightIterator();        while (vertexIterator.hasNext()) {            Vertex<E> vert = (Vertex<E>) vertexIterator.next();            System.out.print(vert + " " + weightIterator.next() + " ");        }        System.out.println();    }    private class Edge    {        private VertexInterface<E> vertex;        private double weight;        protected Edge(VertexInterface<E> endVertex, double edgeWeight)        {            this.vertex = endVertex;            this.weight = edgeWeight;        }        private VertexInterface<E> getEndVertex()        {            return this.vertex;        }        protected double getWeight()        {            return this.weight;        }        public String toString() // for testing only        {            return this.vertex.toString() + " " + this.weight;        }    }    private class NeighborIterator implements Iterator<VertexInterface<E>>    {        private Iterator<Edge> edges;        private NeighborIterator()        {            this.edges = edgeList.iterator();        }        public boolean hasNext()        {            return this.edges.hasNext();        }        public VertexInterface<E> next()        {            VertexInterface<E> nextNeighbor = null;            if (this.edges.hasNext()) {                Edge edgeToNextNeighbor = this.edges.next();                nextNeighbor = edgeToNextNeighbor.getEndVertex();            } else throw new NoSuchElementException();            return nextNeighbor;        }        public void remove()        {            throw new UnsupportedOperationException();        }    }    private class WeightIterator implements Iterator<Double>    {        private Iterator<Edge> edges;        private WeightIterator()        {            this.edges = edgeList.iterator();        }        public boolean hasNext()        {            return this.edges.hasNext();        }        public Double next()        {            Double edgeWeight = new Double(0);            if (this.edges.hasNext()) {                Edge edgeToNextNeighbor = this.edges.next();                edgeWeight = edgeToNextNeighbor.getWeight();            } else throw new NoSuchElementException();            return edgeWeight;        }        public void remove()        {            throw new UnsupportedOperationException();        }    }}